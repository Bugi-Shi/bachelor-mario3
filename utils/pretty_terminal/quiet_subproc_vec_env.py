from __future__ import annotations

import multiprocessing as mp
import warnings
from multiprocessing.connection import Connection
from typing import Any, Callable, Dict, List, Optional, Sequence

import gymnasium as gym
import numpy as np

from utils.pretty_terminal.ignore_signals import ignore_sigint
from stable_baselines3.common.vec_env.base_vec_env import (
    CloudpickleWrapper,
    VecEnv,
    VecEnvIndices,
    VecEnvObs,
    VecEnvStepReturn,
)
from stable_baselines3.common.vec_env.patch_gym import _patch_env


def _quiet_worker(
    remote: Connection,
    parent_remote: Connection,
    env_fn_wrapper: CloudpickleWrapper,
) -> None:
    """SB3 SubprocVecEnv worker that ignores SIGINT.

    This prevents noisy KeyboardInterrupt tracebacks in worker processes when
    the user stops training via Ctrl+C; the main process remains responsible
    for shutdown and will close the VecEnv cleanly.
    """

    ignore_sigint()

    # Import here to avoid circular import, matching SB3 behavior.
    from stable_baselines3.common.env_util import is_wrapped

    parent_remote.close()
    env = _patch_env(env_fn_wrapper.var())
    reset_info: Optional[Dict[str, Any]] = {}

    while True:
        try:
            cmd, data = remote.recv()
        except EOFError:
            break

        if cmd == "step":
            observation, reward, terminated, truncated, info = env.step(data)
            done = bool(terminated or truncated)
            info["TimeLimit.truncated"] = bool(truncated and not terminated)
            if done:
                info["terminal_observation"] = observation
                observation, reset_info = env.reset()
            remote.send((observation, reward, done, info, reset_info))
        elif cmd == "reset":
            maybe_options = {"options": data[1]} if data[1] else {}
            observation, reset_info = env.reset(seed=data[0], **maybe_options)
            remote.send((observation, reset_info))
        elif cmd == "render":
            remote.send(env.render())
        elif cmd == "close":
            env.close()
            remote.close()
            break
        elif cmd == "get_spaces":
            remote.send((env.observation_space, env.action_space))
        elif cmd == "env_method":
            method = env.get_wrapper_attr(data[0])
            remote.send(method(*data[1], **data[2]))
        elif cmd == "get_attr":
            remote.send(env.get_wrapper_attr(data))
        elif cmd == "set_attr":
            remote.send(
                # type: ignore[func-returns-value]
                setattr(env, data[0], data[1])
            )
        elif cmd == "is_wrapped":
            remote.send(is_wrapped(env, data))
        else:
            raise NotImplementedError(
                f"`{cmd}` is not implemented in the worker"
            )


class QuietSubprocVecEnv(VecEnv):
    """Drop-in replacement for SB3 `SubprocVecEnv` with quieter Ctrl+C.

    It behaves like SB3's implementation but starts workers with
    `_quiet_worker` that ignores SIGINT, avoiding worker-side
    KeyboardInterrupt tracebacks.
    """

    def __init__(
        self,
        env_fns: List[Callable[[], gym.Env]],
        start_method: Optional[str] = None,
    ):
        from stable_baselines3.common.vec_env.subproc_vec_env import _stack_obs

        self._stack_obs = _stack_obs
        self.waiting = False
        self.closed = False

        n_envs = len(env_fns)
        if start_method is None:
            forkserver_available = "forkserver" in mp.get_all_start_methods()
            start_method = "forkserver" if forkserver_available else "spawn"
        ctx = mp.get_context(start_method)

        self.remotes, self.work_remotes = zip(
            *[ctx.Pipe() for _ in range(n_envs)]
        )
        self.processes = []
        for work_remote, remote, env_fn in zip(
            self.work_remotes, self.remotes, env_fns
        ):
            args = (work_remote, remote, CloudpickleWrapper(env_fn))
            process = ctx.Process(  # type: ignore[attr-defined]
                target=_quiet_worker,
                args=args,
                daemon=True,
            )
            process.start()
            self.processes.append(process)
            work_remote.close()

        self.remotes[0].send(("get_spaces", None))
        observation_space, action_space = self.remotes[0].recv()
        super().__init__(n_envs, observation_space, action_space)

    def step_async(self, actions: np.ndarray) -> None:
        for remote, action in zip(self.remotes, actions):
            remote.send(("step", action))
        self.waiting = True

    def step_wait(self) -> VecEnvStepReturn:
        results = [remote.recv() for remote in self.remotes]
        self.waiting = False
        obs, rews, dones, infos, reset_infos = zip(*results)
        self.reset_infos = list(reset_infos)  # type: ignore[assignment]
        return (
            self._stack_obs(obs, self.observation_space),
            np.stack(rews),
            np.stack(dones),
            list(infos),
        )

    def reset(self) -> VecEnvObs:
        for env_idx, remote in enumerate(self.remotes):
            remote.send(
                ("reset", (self._seeds[env_idx], self._options[env_idx]))
            )
        results = [remote.recv() for remote in self.remotes]
        obs, self.reset_infos = zip(*results)  # type: ignore[assignment]
        self._reset_seeds()
        self._reset_options()
        return self._stack_obs(obs, self.observation_space)

    def close(self) -> None:
        if self.closed:
            return
        if self.waiting:
            for remote in self.remotes:
                remote.recv()
        for remote in self.remotes:
            remote.send(("close", None))
        for process in self.processes:
            process.join()
        self.closed = True

    def get_images(self) -> Sequence[Optional[np.ndarray]]:
        if self.render_mode != "rgb_array":
            warnings.warn(
                (
                    "The render mode is "
                    f"{self.render_mode}, but this method assumes it is "
                    "`rgb_array` to obtain images."
                )
            )
            return [None for _ in self.remotes]
        for pipe in self.remotes:
            pipe.send(("render", None))
        return [pipe.recv() for pipe in self.remotes]

    def get_attr(
        self, attr_name: str, indices: VecEnvIndices = None
    ) -> List[Any]:
        target_remotes = self._get_target_remotes(indices)
        for remote in target_remotes:
            remote.send(("get_attr", attr_name))
        return [remote.recv() for remote in target_remotes]

    def set_attr(
        self, attr_name: str, value: Any, indices: VecEnvIndices = None
    ) -> None:
        target_remotes = self._get_target_remotes(indices)
        for remote in target_remotes:
            remote.send(("set_attr", (attr_name, value)))
        for remote in target_remotes:
            remote.recv()

    def env_method(
        self,
        method_name: str,
        *method_args,
        indices: VecEnvIndices = None,
        **method_kwargs,
    ) -> List[Any]:
        target_remotes = self._get_target_remotes(indices)
        for remote in target_remotes:
            remote.send(
                ("env_method", (method_name, method_args, method_kwargs))
            )
        return [remote.recv() for remote in target_remotes]

    def env_is_wrapped(
        self, wrapper_class: type, indices: VecEnvIndices = None
    ) -> List[bool]:
        target_remotes = self._get_target_remotes(indices)
        for remote in target_remotes:
            remote.send(("is_wrapped", wrapper_class))
        return [remote.recv() for remote in target_remotes]

    def _get_target_remotes(self, indices: VecEnvIndices) -> List[Any]:
        indices = self._get_indices(indices)
        return [self.remotes[i] for i in indices]
